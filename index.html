<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå AI Book Factory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 15px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 20px;
            text-align: center;
        }
        header h1 { font-size: 1.8em; margin-bottom: 6px; }
        header p { opacity: 0.85; font-size: 0.9em; }

        .section {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }
        .section h2 { color: #667eea; margin-bottom: 15px; font-size: 1.1em; }

        .form-group { margin-bottom: 14px; }
        .form-group label {
            display: block;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        .form-group small { color: #999; font-size: 0.8em; margin-top: 3px; display: block; }

        .custom-box {
            display: none;
            background: #f0f4ff;
            border: 1px solid #c5d0fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
        }

        .btn-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.1s;
        }
        button:active { transform: scale(0.97); }
        .btn-start { background: #667eea; color: white; }
        .btn-pause { background: #ffa726; color: white; }
        .btn-stop  { background: #ef5350; color: white; }
        .btn-clear { background: #78909c; color: white; }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }
        .stat-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 14px;
            border: 1px solid #eee;
        }
        .stat-card .label { font-size: 0.75em; color: #888; margin-bottom: 4px; }
        .stat-card .value { font-size: 1.5em; font-weight: 700; color: #667eea; }

        .badge {
            display: inline-block;
            padding: 3px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: 700;
            margin-left: 8px;
        }
        .badge-run  { background: #4caf50; color: white; }
        .badge-pause{ background: #ff9800; color: white; }
        .badge-stop { background: #9e9e9e; color: white; }

        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 6px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.4s;
        }

        .logs-section {
            background: #1a1a2e;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        .logs-section h3 { color: #fff; margin-bottom: 10px; font-size: 0.95em; }
        .log {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 5px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            border-left: 3px solid #667eea;
            background: #16213e;
            color: #e0e0e0;
            word-break: break-all;
        }
        .log-success { border-color: #4caf50; }
        .log-error   { border-color: #f44336; color: #ffcdd2; }
        .log-warning { border-color: #ff9800; color: #ffe0b2; }
        .log-info    { border-color: #667eea; }
    </style>
</head>
<body>
<div class="container">

    <header>
        <h1>üåå AI Book Factory</h1>
        <p>Autonomous GitHub Scraper ¬∑ LLM RAG Book Builder</p>
    </header>

    <!-- CONFIGURATION -->
    <div class="section">
        <h2>‚öôÔ∏è Configuration</h2>

        <div class="form-group">
            <label>Target GitHub Repository (push destination):</label>
            <input id="targetRepo" value="Tryboy869/ai-books" placeholder="user/repo-name">
            <small>Books will be pushed as: ai.book.{domain}.lrb</small>
        </div>

        <div class="form-group">
            <label>Target Domain:</label>
            <select id="targetDomain" onchange="onDomainChange()">
                <option value="python">Python (.py)</option>
                <option value="rust">Rust (.rs)</option>
                <option value="javascript">JavaScript (.js)</option>
                <option value="typescript">TypeScript (.ts)</option>
                <option value="go">Go (.go)</option>
                <option value="docker">Docker (Dockerfile)</option>
                <option value="kubernetes">Kubernetes (.yaml)</option>
                <option value="github-actions">GitHub Actions (.yml)</option>
                <option value="shell">Shell (.sh)</option>
                <option value="json">JSON (.json)</option>
                <option value="markdown">Markdown (.md)</option>
                <option value="custom">üéØ Custom...</option>
            </select>
        </div>

        <div class="custom-box" id="customBox">
            <div class="form-group">
                <label>Language / Domain Name:</label>
                <input id="customName" placeholder="e.g. solidity, elixir, terraform">
                <small>Used in filename: ai.book.{name}.lrb</small>
            </div>
            <div class="form-group">
                <label>File Extensions (comma-separated):</label>
                <input id="customExts" placeholder=".sol, .vy">
            </div>
            <div class="form-group">
                <label>Dependency Files (optional, comma-separated):</label>
                <input id="customDeps" placeholder="package.json, hardhat.config.js">
            </div>
            <div class="form-group">
                <label>GitHub Search Query (optional):</label>
                <input id="customQuery" placeholder="language:solidity stars:>100">
                <small>Leave empty to auto-generate from name</small>
            </div>
        </div>

        <div class="form-group">
            <label>GitHub Personal Access Token:</label>
            <input id="githubToken" type="password" placeholder="ghp_...">
            <small>Required to push books. Also boosts scraping to 5000 req/h vs 60 req/h</small>
        </div>

        <div class="form-group">
            <label>Quota Limit per Hour: <strong id="quotaLabel">70%</strong></label>
            <input id="quotaLimit" type="range" min="10" max="90" value="70"
                   oninput="document.getElementById('quotaLabel').textContent=this.value+'%'">
        </div>

        <div class="btn-row">
            <button class="btn-start" onclick="startFactory()">üöÄ Start</button>
            <button class="btn-pause" onclick="pauseFactory()">‚è∏Ô∏è Pause</button>
            <button class="btn-stop"  onclick="stopFactory()">‚èπÔ∏è Stop</button>
            <button class="btn-clear" onclick="clearData()">üóëÔ∏è Clear</button>
        </div>
    </div>

    <!-- DASHBOARD -->
    <div class="section">
        <h2>üìä Status <span id="badge" class="badge badge-stop">Stopped</span></h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="label">Current Cycle</div>
                <div class="value" id="sCycle">0</div>
            </div>
            <div class="stat-card">
                <div class="label">Repos Processed</div>
                <div class="value" id="sRepos">0</div>
            </div>
            <div class="stat-card">
                <div class="label">Quota Used</div>
                <div class="value" id="sQuota">0%</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="sQuotaBar" style="width:0%"></div>
                </div>
            </div>
            <div class="stat-card">
                <div class="label">Book Size</div>
                <div class="value" id="sBook">0 KB</div>
            </div>
            <div class="stat-card">
                <div class="label">Next Run</div>
                <div class="value" id="sNext" style="font-size:1em">--</div>
            </div>
            <div class="stat-card">
                <div class="label">Storage Used</div>
                <div class="value" id="sStorage">0 MB</div>
            </div>
        </div>
    </div>

    <!-- LOGS -->
    <div class="logs-section">
        <h3>üìù Activity Logs</h3>
        <div id="logBox"></div>
    </div>

</div>

<script>
// ============================================================================
// STATE
// ============================================================================
let running   = false;
let paused    = false;
let stopFlag  = false;
let db        = null;
let loopTimer = null;

let state = {
    cycle:          0,
    processedRepos: [],
    existingFileSha: null,
    quotaUsed:       0,
    cycleStart:      Date.now(),
    currentBook:     null
};

let cfg = {};

// ============================================================================
// UI HELPERS
// ============================================================================
function onDomainChange() {
    document.getElementById('customBox').style.display =
        document.getElementById('targetDomain').value === 'custom' ? 'block' : 'none';
}

function log(msg, level = 'info') {
    const box   = document.getElementById('logBox');
    const entry = document.createElement('div');
    entry.className = `log log-${level}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    box.insertBefore(entry, box.firstChild);
    while (box.children.length > 120) box.removeChild(box.lastChild);
}

function setStats(s) {
    document.getElementById('sCycle').textContent    = s.cycle ?? state.cycle;
    document.getElementById('sRepos').textContent    = s.repos ?? state.processedRepos.length;
    const q = Math.round((s.quota ?? state.quotaUsed) * 100);
    document.getElementById('sQuota').textContent    = q + '%';
    document.getElementById('sQuotaBar').style.width = q + '%';
    if (s.bookSize != null) {
        const kb = (s.bookSize / 1024).toFixed(1);
        document.getElementById('sBook').textContent = kb > 1024
            ? (kb / 1024).toFixed(2) + ' MB'
            : kb + ' KB';
    }
    if (s.next) document.getElementById('sNext').textContent = s.next;
}

function setBadge(status) {
    const b = document.getElementById('badge');
    const map = {
        running: ['Running',  'badge-run'],
        paused:  ['Paused',   'badge-pause'],
        stopped: ['Stopped',  'badge-stop']
    };
    b.textContent = map[status][0];
    b.className   = `badge ${map[status][1]}`;
}

async function updateStorageStats() {
    if (navigator.storage?.estimate) {
        const e = await navigator.storage.estimate();
        document.getElementById('sStorage').textContent =
            ((e.usage || 0) / 1024 / 1024).toFixed(2) + ' MB';
    }
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ============================================================================
// CONTROLS
// ============================================================================
async function startFactory() {
    if (running) { log('Already running', 'warning'); return; }

    const domain = document.getElementById('targetDomain').value;

    cfg = {
        targetRepo:  document.getElementById('targetRepo').value.trim(),
        githubToken: document.getElementById('githubToken').value.trim(),
        quotaLimit:  parseInt(document.getElementById('quotaLimit').value) / 100,
        customMode:  domain === 'custom'
    };

    if (cfg.customMode) {
        cfg.targetDomain    = document.getElementById('customName').value.trim().toLowerCase();
        cfg.fileExtensions  = document.getElementById('customExts').value.split(',').map(s=>s.trim()).filter(Boolean);
        cfg.dependencyFiles = document.getElementById('customDeps').value.split(',').map(s=>s.trim()).filter(Boolean);
        cfg.searchQuery     = document.getElementById('customQuery').value.trim();
        if (!cfg.targetDomain || !cfg.fileExtensions.length) {
            log('‚ùå Custom mode: please fill Language Name and Extensions', 'error'); return;
        }
    } else {
        cfg.targetDomain    = domain;
        cfg.fileExtensions  = DOMAIN_EXTENSIONS[domain] || ['.txt'];
        cfg.dependencyFiles = DOMAIN_DEPS[domain]       || [];
        cfg.searchQuery     = '';
    }

    if (!cfg.targetRepo) { log('‚ùå Target repository is required', 'error'); return; }
    if (!cfg.githubToken) { log('‚ö†Ô∏è No GitHub token ‚Äî push will be skipped', 'warning'); }

    log(`üöÄ Starting factory ‚Äî domain: ${cfg.targetDomain}`, 'success');
    log(`üìå Repo: ${cfg.targetRepo}`, 'info');

    running  = true;
    paused   = false;
    stopFlag = false;
    setBadge('running');

    db = await openDB();
    const saved = await dbGet('state', 'main');
    if (saved) {
        state = saved;
        log(`‚ôªÔ∏è  Resuming session ‚Äî ${state.processedRepos.length} repos already done`, 'success');
    } else {
        state = { cycle:0, processedRepos:[], existingFileSha:null, quotaUsed:0, cycleStart:Date.now(), currentBook:null };
    }

    setStats({ cycle: state.cycle, repos: state.processedRepos.length, quota: state.quotaUsed });

    runLoop();
}

function pauseFactory() {
    if (!running) { log('Not running', 'warning'); return; }
    paused = !paused;
    setBadge(paused ? 'paused' : 'running');
    log(paused ? '‚è∏Ô∏è Paused' : '‚ñ∂Ô∏è Resumed', 'warning');
}

function stopFactory() {
    if (!running) { log('Not running', 'warning'); return; }
    stopFlag = true;
    running  = false;
    paused   = false;
    if (loopTimer) { clearTimeout(loopTimer); loopTimer = null; }
    setBadge('stopped');
    log('‚èπÔ∏è Factory stopped', 'warning');
    dbSet('state', 'main', state);
}

async function clearData() {
    if (running) { log('‚ùå Stop the factory first', 'error'); return; }
    if (!confirm('Delete ALL stored data?')) return;
    const d = await openDB();
    for (const s of ['state','books','repos']) {
        const tx = d.transaction([s], 'readwrite');
        tx.objectStore(s).clear();
    }
    state = { cycle:0, processedRepos:[], existingFileSha:null, quotaUsed:0, cycleStart:Date.now(), currentBook:null };
    setStats({ cycle:0, repos:0, quota:0, bookSize:0 });
    document.getElementById('sNext').textContent = '--';
    await updateStorageStats();
    log('üóëÔ∏è All data cleared', 'warning');
}

// ============================================================================
// MAIN LOOP (runs in main thread ‚Äî no worker needed)
// ============================================================================
async function runLoop() {
    while (running && !stopFlag) {
        // Pause check
        while (paused && !stopFlag) await sleep(500);
        if (stopFlag) break;

        // Quota check
        if (state.quotaUsed >= cfg.quotaLimit) {
            const elapsed   = Date.now() - state.cycleStart;
            const remaining = Math.max(0, 3600000 - elapsed);
            const mins      = Math.ceil(remaining / 60000);
            log(`‚è∞ Quota limit (${Math.round(state.quotaUsed*100)}%) ‚Äî waiting ${mins} min`, 'warning');
            document.getElementById('sNext').textContent = `${mins} min`;
            setStats({ quota: state.quotaUsed });
            await dbSet('state', 'main', state);
            // AM√âLIORATION 5: Countdown live ‚Äî mise √† jour toutes les 30s
            let timeLeft = remaining;
            while (timeLeft > 0 && running && !stopFlag) {
                const minsLeft = Math.ceil(timeLeft / 60000);
                document.getElementById('sNext').textContent = `${minsLeft}m`;
                const chunk = Math.min(timeLeft, 30000);
                await sleep(chunk);
                timeLeft -= chunk;
            }
            state.quotaUsed   = 0;
            state.cycleStart  = Date.now();
            document.getElementById('sNext').textContent = '--';
        }

        // ---- CYCLE START ----
        state.cycle++;
        log(`\n‚îÅ‚îÅ‚îÅ üîÑ CYCLE ${state.cycle} START ‚îÅ‚îÅ‚îÅ`, 'success');
        setStats({ cycle: state.cycle });

        // Step 1: Check / clone existing book from GitHub
        await cloneOrLoadBook();

        // Step 2: Discover new repos
        const newRepos = await discoverRepos();
        log(`üîç ${newRepos.length} new repos to process`, 'info');

        if (newRepos.length === 0) {
            log('üí§ No new repos found ‚Äî all known repos processed', 'warning');
        }

        // Step 3: Process repos
        for (const repo of newRepos) {
            if (!running || stopFlag) break;
            while (paused && !stopFlag) await sleep(500);
            if (state.quotaUsed >= cfg.quotaLimit) break;
            // Extra safety: skip if already processed (deduplicate)
            if (state.processedRepos.includes(repo.full_name)) {
                log(`‚è≠Ô∏è Skip duplicate: ${repo.full_name}`, 'info');
                continue;
            }
            await processRepo(repo);
            setStats({ repos: state.processedRepos.length, quota: state.quotaUsed });
        }

        // Step 4: Push to GitHub
        await pushBookToGitHub();

        // Step 5: Cleanup temporary data
        await cleanupTemp();

        // Step 6: Save state
        await dbSet('state', 'main', state);

        log(`‚îÅ‚îÅ‚îÅ ‚úÖ CYCLE ${state.cycle} COMPLETE ‚îÅ‚îÅ‚îÅ`, 'success');

        // Wait 60s before next cycle avec countdown live
        log('üí§ Next cycle in 60s...', 'info');
        let waitLeft = 60000;
        while (waitLeft > 0 && running && !stopFlag) {
            document.getElementById('sNext').textContent = `${Math.ceil(waitLeft/1000)}s`;
            const chunk = Math.min(waitLeft, 5000);
            await sleep(chunk);
            waitLeft -= chunk;
        }
        document.getElementById('sNext').textContent = '--';
    }

    if (stopFlag) {
        log('üõë Loop exited cleanly', 'info');
    }
}

// ============================================================================
// STEP 1 ‚Äî CHECK EXISTING BOOK ON GITHUB
// ============================================================================
async function cloneOrLoadBook() {
    const bookFile = `ai.book.${cfg.targetDomain}.lrb`;
    log(`üîç Checking GitHub for: ${bookFile}`, 'info');

    if (!cfg.githubToken) {
        log('‚ö†Ô∏è No token ‚Äî skipping remote check, using local state', 'warning');
        if (!state.currentBook) state.currentBook = makeNewBook();
        return;
    }

    try {
        const url = `https://api.github.com/repos/${cfg.targetRepo}/contents/${bookFile}`;
        const res = await ghFetch(url, 'GET');
        state.quotaUsed += 0.002;

        if (res.ok) {
            const info    = await res.json();
            const raw     = decodeURIComponent(escape(atob(info.content.replace(/\n/g,''))));
            state.currentBook    = JSON.parse(raw);
            state.processedRepos = state.currentBook.repos || [];
            state.existingFileSha = info.sha;
            log(`‚úÖ Book found ‚Äî ${state.processedRepos.length} repos already done (SHA: ${info.sha.slice(0,8)})`, 'success');
        } else if (res.status === 404) {
            state.currentBook    = makeNewBook();
            state.existingFileSha = null;
            log(`üìö No existing book ‚Äî creating new one`, 'info');
        } else {
            throw new Error(`API ${res.status}`);
        }
    } catch (e) {
        if (!state.currentBook) state.currentBook = makeNewBook();
        log(`‚ö†Ô∏è Remote check failed (${e.message}) ‚Äî using local state`, 'warning');
    }
}

function makeNewBook() {
    return {
        domain:   cfg.targetDomain,
        version:  '1.0.0',
        created:  new Date().toISOString(),
        updated:  new Date().toISOString(),
        repos:    [],
        patterns: {},
        metadata: { totalFiles: 0, totalRepos: 0 }
    };
}

// ============================================================================
// STEP 2 ‚Äî DISCOVER REPOS
// ============================================================================
const DOMAIN_EXTENSIONS = {
    python: ['.py'],
    rust: ['.rs'],
    javascript: ['.js','.jsx'],
    typescript: ['.ts','.tsx'],
    go: ['.go'],
    docker: ['Dockerfile','.dockerignore'],
    kubernetes: ['.yaml','.yml'],
    'github-actions': ['.yml','.yaml'],
    shell: ['.sh','.bash'],
    json: ['.json'],
    markdown: ['.md']
};
const DOMAIN_DEPS = {
    python: ['requirements.txt','pyproject.toml','setup.py'],
    rust: ['Cargo.toml'],
    javascript: ['package.json'],
    typescript: ['package.json','tsconfig.json'],
    go: ['go.mod'],
    docker: ['docker-compose.yml'],
    kubernetes: [],
    'github-actions': [],
    shell: ['Makefile'],
    json: [],
    markdown: []
};

async function discoverRepos() {
    const query = cfg.searchQuery || `language:${cfg.targetDomain} stars:>100`;

    // AM√âLIORATION 4: Pagination ‚Äî on tourne sur plusieurs pages pour toujours trouver du nouveau
    // page courante = Math.floor(processedRepos.length / 100) + 1
    const page = Math.max(1, Math.floor(state.processedRepos.length / 80) + 1);
    log(`üîé GitHub search p${page}: "${query}"`, 'info');

    let repos = await githubSearch(query, !!cfg.githubToken, page);

    if (!Array.isArray(repos) || repos.length === 0) {
        // Retry page 1 without token as fallback
        log(`‚ö†Ô∏è Search failed p${page} ‚Äî retrying p1`, 'warning');
        repos = await githubSearch(query, false, 1);
    }

    if (!Array.isArray(repos)) return [];

    const fresh = repos.filter(r => !state.processedRepos.includes(r.full_name));
    log(`üìã ${repos.length} results ‚Äî ${fresh.length} new`, 'info');
    return fresh.slice(0, 20);
}

async function githubSearch(query, useToken, page = 1) {
    try {
        const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&per_page=100&sort=stars&page=${page}`;
        const res = await ghFetch(url, 'GET', useToken);
        state.quotaUsed += 0.002;
        if (!res.ok) {
            if (res.status === 403) return { error: 'rate_limit' };
            return [];
        }
        const d = await res.json();
        return d.items || [];
    } catch (e) {
        log(`‚ùå Search error: ${e.message}`, 'error');
        return [];
    }
}

// ============================================================================
// STEP 3 ‚Äî PROCESS REPO
// ============================================================================
async function processRepo(repo) {
    log(`üìÇ Processing ${repo.full_name}...`, 'info');
    try {
        const files = await fetchRepoFiles(repo);

        if (files.length === 0) {
            log(`‚è≠Ô∏è Skip ${repo.full_name} ‚Äî no matching files`, 'warning');
            state.processedRepos.push(repo.full_name);
            return;
        }

        // AM√âLIORATION 1: Min files filter ‚Äî repo trop vide = pas pertinent
        if (files.length < 3) {
            log(`‚è≠Ô∏è Skip ${repo.full_name} ‚Äî too few files (${files.length})`, 'warning');
            state.processedRepos.push(repo.full_name);
            return;
        }

        // AM√âLIORATION 2: Max single file size (skip fichiers > 500KB = probablement auto-g√©n√©r√©s)
        const oversized = files.filter(f => (f.size || 0) > 512000);
        if (oversized.length > 0) {
            log(`‚ö†Ô∏è ${repo.full_name} ‚Äî removing ${oversized.length} oversized files`, 'warning');
        }
        const cleanFiles = files.filter(f => (f.size || 0) <= 512000);
        if (cleanFiles.length === 0) {
            log(`‚è≠Ô∏è Skip ${repo.full_name} ‚Äî all files oversized`, 'warning');
            state.processedRepos.push(repo.full_name);
            return;
        }

        // Store temporarily in IndexedDB
        await dbSet('repos', repo.full_name, cleanFiles);

        // AM√âLIORATION 3: Cat√©gorisation automatique par dossier racine
        const categories = {};
        cleanFiles.forEach(f => {
            const topDir = f.path.includes('/') ? f.path.split('/')[0] : 'root';
            if (!categories[topDir]) categories[topDir] = 0;
            categories[topDir]++;
        });
        const topCats = Object.entries(categories)
            .sort((a,b) => b[1]-a[1])
            .slice(0,5)
            .map(([k,v]) => k);

        // Build pattern entry
        const pattern = {
            files:      cleanFiles.length,
            totalSize:  cleanFiles.reduce((s, f) => s + (f.size || 0), 0),
            paths:      cleanFiles.map(f => f.path),
            categories: topCats,
            scraped:    new Date().toISOString()
        };

        if (!state.currentBook.patterns[cfg.targetDomain])
            state.currentBook.patterns[cfg.targetDomain] = {};

        state.currentBook.patterns[cfg.targetDomain][repo.full_name] = pattern;
        state.currentBook.repos.push(repo.full_name);
        state.processedRepos.push(repo.full_name);
        state.currentBook.metadata.totalFiles += cleanFiles.length;
        state.currentBook.metadata.totalRepos  = state.processedRepos.length;

        log(`‚úÖ ${repo.full_name} ‚Äî ${cleanFiles.length} files | cats: ${topCats.join(', ')}`, 'success');
    } catch (e) {
        log(`‚ùå Failed ${repo.full_name}: ${e.message}`, 'error');
    }
}

async function fetchRepoFiles(repo) {
    const branch = repo.default_branch || 'main';
    const urls   = [
        `https://api.github.com/repos/${repo.full_name}/git/trees/${branch}?recursive=1`,
        `https://api.github.com/repos/${repo.full_name}/git/trees/master?recursive=1`
    ];

    for (const url of urls) {
        try {
            const res = await ghFetch(url, 'GET');
            state.quotaUsed += 0.002;
            if (!res.ok) continue;
            const data = await res.json();
            return filterFiles(data.tree || []);
        } catch (e) { continue; }
    }
    return [];
}

function filterFiles(tree) {
    const exts = cfg.fileExtensions;
    const deps = cfg.dependencyFiles || [];

    return tree
        .filter(f => f.type === 'blob')
        .filter(f => {
            const name    = f.path.split('/').pop();
            const hasExt  = exts.some(e => f.path.endsWith(e));
            const isDep   = deps.some(d => name === d || f.path.endsWith(d));
            return hasExt || isDep;
        })
        .slice(0, 50);
}

// ============================================================================
// STEP 4 ‚Äî PUSH TO GITHUB
// ============================================================================
async function pushBookToGitHub() {
    // Deduplicate repos list before pushing
    state.currentBook.repos = [...new Set(state.currentBook.repos)];
    state.processedRepos    = [...new Set(state.processedRepos)];
    state.currentBook.metadata.totalRepos = state.currentBook.repos.length;

    // AM√âLIORATION 6: Version bump automatique (1.0.0 ‚Üí 1.0.1 ‚Üí 1.0.2...)
    const parts = (state.currentBook.version || '1.0.0').split('.').map(Number);
    parts[2]++;
    if (parts[2] >= 100) { parts[2] = 0; parts[1]++; }
    if (parts[1] >= 100) { parts[1] = 0; parts[0]++; }
    state.currentBook.version = parts.join('.');
    state.currentBook.metadata.totalSize = Object.values(
        state.currentBook.patterns[cfg.targetDomain] || {}
    ).reduce((sum, r) => sum + (r.totalSize || 0), 0);
    if (!cfg.githubToken) {
        log('‚ö†Ô∏è No token ‚Äî skipping GitHub push', 'warning');
        await dbSet('books', cfg.targetDomain, state.currentBook);
        return;
    }

    state.currentBook.updated = new Date().toISOString();
    const bookFile  = `ai.book.${cfg.targetDomain}.lrb`;
    const bookJson  = JSON.stringify(state.currentBook, null, 2);
    const bookSize  = new Blob([bookJson]).size;
    const encoded   = btoa(unescape(encodeURIComponent(bookJson)));

    log(`üì§ Pushing ${bookFile} (${(bookSize/1024).toFixed(1)} KB)...`, 'info');

    const url  = `https://api.github.com/repos/${cfg.targetRepo}/contents/${bookFile}`;
    const body = {
        message: `üìö Update ${bookFile} ‚Äî ${state.processedRepos.length} repos [cycle ${state.cycle}] ${new Date().toISOString()}`,
        content: encoded
    };

    if (state.existingFileSha) {
        body.sha = state.existingFileSha;
        log(`üîÑ Updating file (SHA: ${state.existingFileSha.slice(0,8)}...)`, 'info');
    } else {
        log(`üÜï Creating file (first push)`, 'info');
    }

    try {
        const res = await ghFetch(url, 'PUT', true, body);
        state.quotaUsed += 0.003;

        if (res.ok) {
            const result = await res.json();
            state.existingFileSha = result.content.sha;
            setStats({ bookSize });
            log(`‚úÖ Pushed! Commit: ${result.commit.sha.slice(0,8)}`, 'success');
            log(`üîó ${result.commit.html_url}`, 'success');
        } else {
            const err = await res.json().catch(() => ({}));
            throw new Error(err.message || `HTTP ${res.status}`);
        }
    } catch (e) {
        log(`‚ùå Push failed: ${e.message}`, 'error');
        log(`üíæ Saved locally in IndexedDB`, 'warning');
        await dbSet('books', cfg.targetDomain, state.currentBook);
    }
}

// ============================================================================
// STEP 5 ‚Äî CLEANUP
// ============================================================================
async function cleanupTemp() {
    log('üóëÔ∏è Cleaning temporary repo data...', 'info');
    try {
        const d  = await openDB();
        const tx = d.transaction(['repos'], 'readwrite');
        tx.objectStore('repos').clear();
        await updateStorageStats();
        log('‚úÖ Temp data cleaned', 'success');
    } catch (e) {
        log(`‚ö†Ô∏è Cleanup error: ${e.message}`, 'warning');
    }
}

// ============================================================================
// GITHUB FETCH HELPER
// ============================================================================
function ghFetch(url, method = 'GET', useToken = true, body = null) {
    const headers = { 'Accept': 'application/vnd.github.v3+json' };
    if (useToken && cfg.githubToken) headers['Authorization'] = `token ${cfg.githubToken}`;
    if (body) headers['Content-Type'] = 'application/json';
    return fetch(url, {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined
    });
}

// ============================================================================
// INDEXEDDB
// ============================================================================
function openDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open('AIBookFactory', 2);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = e => {
            const d = e.target.result;
            ['state','books','repos'].forEach(s => {
                if (!d.objectStoreNames.contains(s)) d.createObjectStore(s);
            });
        };
    });
}

function dbGet(store, key) {
    return openDB().then(d => new Promise((res, rej) => {
        const req = d.transaction([store], 'readonly').objectStore(store).get(key);
        req.onsuccess = () => res(req.result);
        req.onerror   = () => rej(req.error);
    }));
}

function dbSet(store, key, value) {
    return openDB().then(d => new Promise((res, rej) => {
        const req = d.transaction([store], 'readwrite').objectStore(store).put(value, key);
        req.onsuccess = () => res();
        req.onerror   = () => rej(req.error);
    }));
}

// ============================================================================
// INIT
// ============================================================================
window.addEventListener('load', async () => {
    log('üåå AI Book Factory ready', 'success');
    db = await openDB();
    const saved = await dbGet('state', 'main');
    if (saved) {
        state = saved;
        setStats({ cycle: state.cycle, repos: state.processedRepos.length, quota: state.quotaUsed });
        log(`‚ôªÔ∏è  Previous session found ‚Äî ${state.processedRepos.length} repos already processed`, 'info');
    }
    await updateStorageStats();
});
</script>
</body>
</html>
