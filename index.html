<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå AI Book Factory - Autonomous GitHub Scraper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        header p {
            opacity: 0.9;
        }
        
        .config-section {
            padding: 30px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .config-section h2 {
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-start {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-pause {
            background: #ffa726;
            color: white;
        }
        
        .btn-stop {
            background: #ef5350;
            color: white;
        }
        
        .btn-clear {
            background: #78909c;
            color: white;
        }
        
        .dashboard {
            padding: 30px;
            background: #f8f9fa;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            font-size: 14px;
            color: #78909c;
            margin-bottom: 10px;
        }
        
        .stat-card .value {
            font-size: 28px;
            font-weight: 700;
            color: #667eea;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
        }
        
        .logs-section {
            padding: 30px;
            background: #1e1e1e;
            color: #d4d4d4;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .logs-section h3 {
            color: #fff;
            margin-bottom: 15px;
        }
        
        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            padding: 8px;
            border-left: 3px solid #667eea;
            margin-bottom: 5px;
            background: #2d2d2d;
            border-radius: 4px;
        }
        
        .log-success {
            border-left-color: #4caf50;
        }
        
        .log-error {
            border-left-color: #f44336;
        }
        
        .log-warning {
            border-left-color: #ff9800;
        }
        
        .status-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .status-running {
            background: #4caf50;
            color: white;
        }
        
        .status-paused {
            background: #ff9800;
            color: white;
        }
        
        .status-stopped {
            background: #9e9e9e;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåå AI Book Factory</h1>
            <p>Autonomous GitHub Repository Scraper & LLM RAG Book Builder</p>
        </header>
        
        <!-- CONFIGURATION -->
        <div class="config-section">
            <h2>‚öôÔ∏è Configuration</h2>
            
            <div class="form-group">
                <label for="targetRepo">Target GitHub Repository (for pushing books):</label>
                <input type="text" id="targetRepo" placeholder="e.g., Tryboy869/ai-books" value="Tryboy869/ai-books">
            </div>
            
            <div class="form-group">
                <label for="targetDomain">Target Domain:</label>
                <select id="targetDomain" onchange="toggleCustomMode()">
                    <option value="python">Python</option>
                    <option value="rust">Rust</option>
                    <option value="javascript">JavaScript</option>
                    <option value="typescript">TypeScript</option>
                    <option value="go">Go</option>
                    <option value="docker">Docker</option>
                    <option value="kubernetes">Kubernetes</option>
                    <option value="github-actions">GitHub Actions</option>
                    <option value="shell">Shell Scripts</option>
                    <option value="json">JSON Configs</option>
                    <option value="yaml">YAML Configs</option>
                    <option value="markdown">Markdown Docs</option>
                    <option value="custom">üéØ Custom (Your own config)</option>
                </select>
            </div>
            
            <!-- CUSTOM MODE CONFIGURATION -->
            <div id="customConfig" style="display: none; padding: 20px; background: #f0f4ff; border-radius: 10px; margin-top: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px;">üéØ Custom Configuration</h3>
                
                <div class="form-group">
                    <label for="customLanguage">Language/Domain Name:</label>
                    <input type="text" id="customLanguage" placeholder="e.g., solidity, elixir, swift, terraform">
                    <small style="color: #78909c;">This will be used for the book filename: ai.book.{name}.lrb</small>
                </div>
                
                <div class="form-group">
                    <label for="customExtensions">File Extensions (comma-separated):</label>
                    <input type="text" id="customExtensions" placeholder="e.g., .sol, .ex, .exs, .swift, .tf">
                    <small style="color: #78909c;">Example: .py, .pyw for Python | .rs for Rust | .sol for Solidity</small>
                </div>
                
                <div class="form-group">
                    <label for="customDependencyFiles">Dependency Files (optional, comma-separated):</label>
                    <input type="text" id="customDependencyFiles" placeholder="e.g., package.json, Cargo.toml, requirements.txt">
                    <small style="color: #78909c;">Config files that define dependencies. Leave empty if not needed.</small>
                </div>
                
                <div class="form-group">
                    <label for="customSearchQuery">GitHub Search Query (optional):</label>
                    <input type="text" id="customSearchQuery" placeholder="e.g., language:solidity stars:>100">
                    <small style="color: #78909c;">Advanced: Custom GitHub search. Leave empty to use language:{name}</small>
                </div>
            </div>
            
            <div class="form-group">
                <label for="githubToken">GitHub Personal Access Token (optional, for higher rate limits):</label>
                <input type="password" id="githubToken" placeholder="ghp_...">
                <small style="color: #78909c;">Without token: 60 requests/hour. With token: 5000 requests/hour.</small>
            </div>
            
            <div class="form-group">
                <label for="quotaLimit">Quota Limit per Hour (%):</label>
                <input type="number" id="quotaLimit" value="70" min="10" max="95">
                <small style="color: #78909c;">Recommended: 70% to avoid rate limiting</small>
            </div>
            
            <div class="button-group">
                <button class="btn-start" onclick="startFactory()">üöÄ Start Factory</button>
                <button class="btn-pause" onclick="pauseFactory()">‚è∏Ô∏è Pause</button>
                <button class="btn-stop" onclick="stopFactory()">‚èπÔ∏è Stop</button>
                <button class="btn-clear" onclick="clearData()">üóëÔ∏è Clear All Data</button>
            </div>
        </div>
        
        <!-- DASHBOARD -->
        <div class="dashboard">
            <h2>üìä Factory Status <span id="statusBadge" class="status-badge status-stopped">Stopped</span></h2>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Current Cycle</h3>
                    <div class="value" id="cycleCount">0</div>
                </div>
                
                <div class="stat-card">
                    <h3>Repos Processed</h3>
                    <div class="value" id="reposProcessed">0</div>
                </div>
                
                <div class="stat-card">
                    <h3>Quota Used</h3>
                    <div class="value" id="quotaUsed">0%</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="quotaProgress" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>Book Size</h3>
                    <div class="value" id="bookSize">0 MB</div>
                </div>
                
                <div class="stat-card">
                    <h3>Next Run</h3>
                    <div class="value" id="nextRun" style="font-size: 18px;">--</div>
                </div>
                
                <div class="stat-card">
                    <h3>Storage Used</h3>
                    <div class="value" id="storageUsed">0 MB</div>
                </div>
            </div>
        </div>
        
        <!-- LOGS -->
        <div class="logs-section">
            <h3>üìù Activity Logs</h3>
            <div id="logs"></div>
        </div>
    </div>
    
    <script>
        // ========================================================================
        // GLOBAL STATE
        // ========================================================================
        
        let worker = null;
        let factoryState = {
            running: false,
            paused: false,
            cycle: 0,
            reposProcessed: 0,
            quotaUsed: 0,
            bookSize: 0,
            storageUsed: 0
        };
        
        // ========================================================================
        // INITIALIZATION
        // ========================================================================
        
        window.addEventListener('load', async () => {
            addLog('üåå AI Book Factory initialized', 'success');
            
            // Load saved state
            await loadState();
            
            // Check IndexedDB usage
            await updateStorageStats();
        });
        
        // ========================================================================
        // CUSTOM MODE TOGGLE
        // ========================================================================
        
        function toggleCustomMode() {
            const domain = document.getElementById('targetDomain').value;
            const customConfig = document.getElementById('customConfig');
            
            if (domain === 'custom') {
                customConfig.style.display = 'block';
            } else {
                customConfig.style.display = 'none';
            }
        }
        
        // ========================================================================
        // FACTORY CONTROL
        // ========================================================================
        
        async function startFactory() {
            if (factoryState.running) {
                addLog('‚ö†Ô∏è Factory already running', 'warning');
                return;
            }
            
            const targetDomain = document.getElementById('targetDomain').value;
            
            let config = {
                targetRepo: document.getElementById('targetRepo').value,
                githubToken: document.getElementById('githubToken').value,
                quotaLimit: parseInt(document.getElementById('quotaLimit').value) / 100
            };
            
            // Handle custom mode
            if (targetDomain === 'custom') {
                const customLanguage = document.getElementById('customLanguage').value.trim();
                const customExtensions = document.getElementById('customExtensions').value.trim();
                
                if (!customLanguage || !customExtensions) {
                    addLog('‚ùå Custom mode requires Language Name and File Extensions', 'error');
                    return;
                }
                
                config.targetDomain = customLanguage.toLowerCase().replace(/\s+/g, '-');
                config.customMode = true;
                config.fileExtensions = customExtensions.split(',').map(ext => ext.trim());
                config.dependencyFiles = document.getElementById('customDependencyFiles').value
                    .split(',')
                    .map(f => f.trim())
                    .filter(f => f.length > 0);
                config.searchQuery = document.getElementById('customSearchQuery').value.trim() || 
                                    `language:${customLanguage} stars:>50`;
                
                addLog(`üéØ Custom mode activated: ${customLanguage}`, 'info');
                addLog(`üìÑ Extensions: ${config.fileExtensions.join(', ')}`, 'info');
                if (config.dependencyFiles.length > 0) {
                    addLog(`üì¶ Dependency files: ${config.dependencyFiles.join(', ')}`, 'info');
                }
            } else {
                config.targetDomain = targetDomain;
                config.customMode = false;
            }
            
            if (!config.targetRepo) {
                addLog('‚ùå Please specify target repository', 'error');
                return;
            }
            
            addLog('üöÄ Starting AI Book Factory...', 'success');
            addLog(`üìå Target: ${config.targetRepo}`, 'info');
            addLog(`üéØ Domain: ${config.targetDomain}`, 'info');
            
            factoryState.running = true;
            factoryState.paused = false;
            updateStatusBadge();
            
            // Create worker
            const workerCode = generateWorkerCode();
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            
            worker = new Worker(workerUrl);
            
            // Handle messages from worker
            worker.onmessage = handleWorkerMessage;
            
            // Start worker
            worker.postMessage({ type: 'start', config });
        }
        
        function pauseFactory() {
            if (!factoryState.running) {
                addLog('‚ö†Ô∏è Factory not running', 'warning');
                return;
            }
            
            factoryState.paused = !factoryState.paused;
            
            if (factoryState.paused) {
                addLog('‚è∏Ô∏è Factory paused', 'warning');
                worker.postMessage({ type: 'pause' });
            } else {
                addLog('‚ñ∂Ô∏è Factory resumed', 'success');
                worker.postMessage({ type: 'resume' });
            }
            
            updateStatusBadge();
        }
        
        function stopFactory() {
            if (!factoryState.running) {
                addLog('‚ö†Ô∏è Factory not running', 'warning');
                return;
            }
            
            addLog('‚èπÔ∏è Stopping factory...', 'warning');
            
            if (worker) {
                worker.postMessage({ type: 'stop' });
                worker.terminate();
                worker = null;
            }
            
            factoryState.running = false;
            factoryState.paused = false;
            updateStatusBadge();
            
            addLog('‚úÖ Factory stopped', 'success');
        }
        
        async function clearData() {
            if (factoryState.running) {
                addLog('‚ùå Stop factory before clearing data', 'error');
                return;
            }
            
            if (!confirm('‚ö†Ô∏è This will delete all stored data. Continue?')) {
                return;
            }
            
            addLog('üóëÔ∏è Clearing all data...', 'warning');
            
            // Clear IndexedDB
            await clearIndexedDB();
            
            // Reset state
            factoryState = {
                running: false,
                paused: false,
                cycle: 0,
                reposProcessed: 0,
                quotaUsed: 0,
                bookSize: 0,
                storageUsed: 0
            };
            
            updateDashboard();
            await updateStorageStats();
            
            addLog('‚úÖ All data cleared', 'success');
        }
        
        // ========================================================================
        // WORKER MESSAGE HANDLER
        // ========================================================================
        
        function handleWorkerMessage(event) {
            const { type, data } = event.data;
            
            switch (type) {
                case 'log':
                    addLog(data.message, data.level || 'info');
                    break;
                    
                case 'stats':
                    factoryState.cycle = data.cycle || factoryState.cycle;
                    factoryState.reposProcessed = data.reposProcessed || factoryState.reposProcessed;
                    factoryState.quotaUsed = data.quotaUsed || factoryState.quotaUsed;
                    factoryState.bookSize = data.bookSize || factoryState.bookSize;
                    updateDashboard();
                    break;
                    
                case 'storage-update':
                    updateStorageStats();
                    break;
                    
                case 'error':
                    addLog(`‚ùå Error: ${data.message}`, 'error');
                    break;
                    
                case 'complete':
                    addLog('‚úÖ Cycle complete, waiting for next hour...', 'success');
                    break;
            }
        }
        
        // ========================================================================
        // UI UPDATES
        // ========================================================================
        
        function updateDashboard() {
            document.getElementById('cycleCount').textContent = factoryState.cycle;
            document.getElementById('reposProcessed').textContent = factoryState.reposProcessed;
            document.getElementById('quotaUsed').textContent = Math.round(factoryState.quotaUsed * 100) + '%';
            document.getElementById('quotaProgress').style.width = (factoryState.quotaUsed * 100) + '%';
            document.getElementById('bookSize').textContent = (factoryState.bookSize / 1024 / 1024).toFixed(2) + ' MB';
        }
        
        function updateStatusBadge() {
            const badge = document.getElementById('statusBadge');
            
            if (factoryState.running && !factoryState.paused) {
                badge.textContent = 'Running';
                badge.className = 'status-badge status-running';
            } else if (factoryState.paused) {
                badge.textContent = 'Paused';
                badge.className = 'status-badge status-paused';
            } else {
                badge.textContent = 'Stopped';
                badge.className = 'status-badge status-stopped';
            }
        }
        
        function addLog(message, level = 'info') {
            const logsDiv = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = 'log-entry log-' + level;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logsDiv.insertBefore(entry, logsDiv.firstChild);
            
            // Keep only last 100 logs
            while (logsDiv.children.length > 100) {
                logsDiv.removeChild(logsDiv.lastChild);
            }
        }
        
        async function updateStorageStats() {
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                const estimate = await navigator.storage.estimate();
                const used = estimate.usage || 0;
                factoryState.storageUsed = used;
                document.getElementById('storageUsed').textContent = (used / 1024 / 1024).toFixed(2) + ' MB';
            }
        }
        
        // ========================================================================
        // STATE PERSISTENCE
        // ========================================================================
        
        async function loadState() {
            try {
                const db = await openDB();
                const tx = db.transaction(['state'], 'readonly');
                const store = tx.objectStore('state');
                const savedState = await store.get('factoryState');
                
                if (savedState) {
                    factoryState = savedState;
                    updateDashboard();
                    updateStatusBadge();
                    addLog('‚úÖ State loaded from previous session', 'success');
                }
            } catch (e) {
                addLog('‚ö†Ô∏è Could not load previous state', 'warning');
            }
        }
        
        // ========================================================================
        // INDEXEDDB UTILITIES
        // ========================================================================
        
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AIBookFactory', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    if (!db.objectStoreNames.contains('state')) {
                        db.createObjectStore('state');
                    }
                    
                    if (!db.objectStoreNames.contains('books')) {
                        db.createObjectStore('books');
                    }
                    
                    if (!db.objectStoreNames.contains('repos')) {
                        db.createObjectStore('repos');
                    }
                };
            });
        }
        
        async function clearIndexedDB() {
            const db = await openDB();
            const tx = db.transaction(['state', 'books', 'repos'], 'readwrite');
            
            await tx.objectStore('state').clear();
            await tx.objectStore('books').clear();
            await tx.objectStore('repos').clear();
            
            await tx.complete;
        }
        
        // ========================================================================
        // WORKER CODE GENERATION
        // ========================================================================
        
        function generateWorkerCode() {
            return `
// ============================================================================
// AI BOOK FACTORY WORKER
// ============================================================================

let config = null;
let state = {
    running: false,
    paused: false,
    cycle: 0,
    processedRepos: [],
    currentBook: null,
    quotaUsed: 0,
    quotaLimit: 0.7,
    cycleStartTime: Date.now()
};

let db = null;

// ============================================================================
// WORKER MESSAGE HANDLER
// ============================================================================

self.onmessage = async function(event) {
    const { type, config: newConfig } = event.data;
    
    switch (type) {
        case 'start':
            config = newConfig;
            state.quotaLimit = config.quotaLimit;
            await initFactory();
            break;
            
        case 'pause':
            state.paused = true;
            break;
            
        case 'resume':
            state.paused = false;
            break;
            
        case 'stop':
            state.running = false;
            await cleanup();
            break;
    }
};

// ============================================================================
// INITIALIZATION
// ============================================================================

async function initFactory() {
    log('üîß Initializing factory...', 'info');
    
    // Open IndexedDB
    db = await openDB();
    
    // Load state
    const savedState = await loadState();
    if (savedState) {
        state = { ...state, ...savedState };
        log('‚úÖ Loaded previous state', 'success');
    }
    
    // Clone existing book
    await cloneExistingBook();
    
    // Start main loop
    state.running = true;
    mainLoop();
}

// ============================================================================
// MAIN LOOP
// ============================================================================

async function mainLoop() {
    while (state.running) {
        if (state.paused) {
            await sleep(1000);
            continue;
        }
        
        // Check quota
        if (state.quotaUsed >= state.quotaLimit) {
            log(\`‚è∏Ô∏è Quota limit reached (\${Math.round(state.quotaUsed * 100)}%), waiting for next hour...\`, 'warning');
            await waitNextHour();
            state.quotaUsed = 0;
            state.cycleStartTime = Date.now();
        }
        
        // Increment cycle
        state.cycle++;
        updateStats();
        
        log(\`üîÑ Starting cycle \${state.cycle}...\`, 'info');
        
        // Discover new repos
        const newRepos = await discoverRepos();
        log(\`üîç Found \${newRepos.length} new repositories\`, 'info');
        
        // Process repos
        for (const repo of newRepos) {
            if (!state.running || state.paused) break;
            if (state.quotaUsed >= state.quotaLimit) break;
            
            await processRepo(repo);
        }
        
        // Update book
        await updateBook();
        
        // Save state
        await saveState();
        
        // Cleanup temporary data
        await cleanupTemporaryData();
        
        log('‚úÖ Cycle complete', 'success');
        postMessage({ type: 'complete' });
        
        // Sleep before next cycle
        await sleep(60000); // 1 minute
    }
}

// ============================================================================
// REPO DISCOVERY
// ============================================================================

async function discoverRepos() {
    const domain = config.targetDomain;
    
    // Use custom search query if in custom mode
    const searchQuery = config.customMode && config.searchQuery ? 
        config.searchQuery : 
        \`language:\${domain} stars:>50\`;
    
    log(\`üîé Searching GitHub: \${searchQuery}\`, 'info');
    
    try {
        // Try without token first
        let repos = await githubSearch(searchQuery, false);
        
        // If rate limited, use token
        if (repos.error === 'rate_limit') {
            log('‚ö†Ô∏è Rate limited, using token...', 'warning');
            repos = await githubSearch(searchQuery, true);
        }
        
        // Filter already processed
        const newRepos = repos.filter(r => 
            !state.processedRepos.includes(r.full_name)
        );
        
        return newRepos.slice(0, 20); // Process 20 per cycle
    } catch (e) {
        log(\`‚ùå Search failed: \${e.message}\`, 'error');
        return [];
    }
}

async function githubSearch(query, useToken) {
    const url = \`https://api.github.com/search/repositories?q=\${encodeURIComponent(query)}&per_page=100&sort=stars\`;
    
    const headers = {
        'Accept': 'application/vnd.github.v3+json'
    };
    
    if (useToken && config.githubToken) {
        headers['Authorization'] = \`token \${config.githubToken}\`;
    }
    
    const response = await fetch(url, { headers });
    
    // Track quota
    state.quotaUsed += 0.001;
    
    if (response.status === 403) {
        return { error: 'rate_limit' };
    }
    
    if (!response.ok) {
        throw new Error(\`GitHub API error: \${response.status}\`);
    }
    
    const data = await response.json();
    return data.items || [];
}

// ============================================================================
// REPO PROCESSING
// ============================================================================

async function processRepo(repo) {
    log(\`üìÇ Processing \${repo.full_name}...\`, 'info');
    
    try {
        // Fetch repo files
        const files = await fetchRepoFiles(repo);
        
        if (files.length === 0) {
            log(\`‚ö†Ô∏è No files found in \${repo.full_name}\`, 'warning');
            return;
        }
        
        // Store temporarily in IndexedDB
        await storeTemporaryFiles(repo.full_name, files);
        
        // Extract patterns
        const patterns = extractPatterns(files);
        
        // Compress patterns
        const compressed = compressPatterns(patterns);
        
        // Add to book
        if (!state.currentBook.patterns[config.targetDomain]) {
            state.currentBook.patterns[config.targetDomain] = {};
        }
        
        state.currentBook.patterns[config.targetDomain][repo.full_name] = compressed;
        state.currentBook.repos.push(repo.full_name);
        state.processedRepos.push(repo.full_name);
        
        updateStats();
        
        log(\`‚úÖ Processed \${repo.full_name} (\${files.length} files)\`, 'success');
        
    } catch (e) {
        log(\`‚ùå Failed to process \${repo.full_name}: \${e.message}\`, 'error');
    }
}

async function fetchRepoFiles(repo) {
    // Get repo tree
    const treeUrl = \`https://api.github.com/repos/\${repo.full_name}/git/trees/\${repo.default_branch || 'main'}?recursive=1\`;
    
    const headers = config.githubToken ? 
        { 'Authorization': \`token \${config.githubToken}\` } : {};
    
    const response = await fetch(treeUrl, { headers });
    state.quotaUsed += 0.001;
    
    if (!response.ok) {
        // Try master branch
        const masterUrl = \`https://api.github.com/repos/\${repo.full_name}/git/trees/master?recursive=1\`;
        const masterResponse = await fetch(masterUrl, { headers });
        state.quotaUsed += 0.001;
        
        if (!masterResponse.ok) {
            return [];
        }
        
        const data = await masterResponse.json();
        return filterFiles(data.tree || [], config.targetDomain);
    }
    
    const data = await response.json();
    return filterFiles(data.tree || [], config.targetDomain);
}

function filterFiles(tree, domain) {
    // Custom mode: use provided extensions
    if (config.customMode) {
        const extensions = config.fileExtensions;
        const dependencyFiles = config.dependencyFiles || [];
        
        return tree
            .filter(item => item.type === 'blob')
            .filter(item => {
                // Match file extensions
                const matchesExt = extensions.some(ext => item.path.endsWith(ext));
                
                // Match dependency files
                const matchesDep = dependencyFiles.some(dep => {
                    const fileName = item.path.split('/').pop();
                    return fileName === dep || item.path.endsWith(dep);
                });
                
                return matchesExt || matchesDep;
            })
            .slice(0, 50); // Limit to 50 files per repo
    }
    
    // Predefined mode: use built-in extensions
    const extensions = {
        'python': ['.py'],
        'rust': ['.rs'],
        'javascript': ['.js', '.jsx'],
        'typescript': ['.ts', '.tsx'],
        'go': ['.go'],
        'docker': ['Dockerfile', '.dockerignore'],
        'kubernetes': ['.yaml', '.yml'],
        'github-actions': ['.yml', '.yaml'],
        'shell': ['.sh', '.bash'],
        'json': ['.json'],
        'yaml': ['.yaml', '.yml'],
        'markdown': ['.md']
    };
    
    const exts = extensions[domain] || [];
    
    return tree
        .filter(item => item.type === 'blob')
        .filter(item => exts.some(ext => item.path.endsWith(ext)))
        .slice(0, 50); // Limit to 50 files per repo
}

// ============================================================================
// PATTERN EXTRACTION & COMPRESSION
// ============================================================================

function extractPatterns(files) {
    // Simple extraction: just store file paths and sizes
    return files.map(f => ({
        path: f.path,
        size: f.size,
        sha: f.sha
    }));
}

function compressPatterns(patterns) {
    // Gravitational compression simulation
    // In real implementation, apply actual compression
    return {
        files: patterns.length,
        totalSize: patterns.reduce((sum, p) => sum + (p.size || 0), 0),
        compressed: true
    };
}

// ============================================================================
// BOOK MANAGEMENT
// ============================================================================

async function cloneExistingBook() {
    const bookFileName = `ai.book.${config.targetDomain}.lrb`;
    log(`üîç Checking repo for existing: ${bookFileName}`, 'info');
    
    try {
        const apiUrl = `https://api.github.com/repos/${config.targetRepo}/contents/${bookFileName}`;
        const headers = {
            'Accept': 'application/vnd.github.v3+json',
            'Authorization': `token ${config.githubToken}`
        };
        
        const response = await fetch(apiUrl, { headers });
        state.quotaUsed += 0.001;
        
        if (response.ok) {
            const fileInfo = await response.json();
            const decoded = decodeURIComponent(escape(atob(fileInfo.content.replace(/\n/g, ''))));
            state.currentBook = JSON.parse(decoded);
            state.processedRepos = state.currentBook.repos || [];
            state.existingFileSha = fileInfo.sha;
            log(`‚úÖ Found existing book: ${state.processedRepos.length} repos already processed`, 'success');
            log(`üìå Book SHA: ${fileInfo.sha.substring(0, 8)}...`, 'info');
        } else if (response.status === 404) {
            state.currentBook = createNewBook();
            state.existingFileSha = null;
            log(`üìö No existing book found - starting fresh`, 'info');
        } else {
            throw new Error(`GitHub API error: ${response.status}`);
        }
    } catch (e) {
        state.currentBook = createNewBook();
        state.existingFileSha = null;
        log(`‚ö†Ô∏è Could not check repo: ${e.message} - starting fresh`, 'warning');
    }
}

function createNewBook() {
    return {
        domain: config.targetDomain,
        version: '1.0.0',
        created: new Date().toISOString(),
        updated: new Date().toISOString(),
        repos: [],
        patterns: {},
        metadata: { totalFiles: 0, totalSize: 0 }
    };
}

async function updateBook() {
    state.currentBook.updated = new Date().toISOString();
    state.currentBook.metadata.totalRepos = state.processedRepos.length;
    
    const bookJson = JSON.stringify(state.currentBook, null, 2);
    const bookSize = new Blob([bookJson]).size;
    
    await storeBook(state.currentBook);
    updateStats();
    
    log(`üìä Book updated locally: ${state.processedRepos.length} repos, ${(bookSize / 1024).toFixed(2)} KB`, 'info');
    
    await pushBookToGitHub(bookJson, bookSize);
}

async function pushBookToGitHub(bookJson, bookSize) {
    if (!config.githubToken) {
        log(`‚ö†Ô∏è No GitHub token provided - cannot push to GitHub`, 'warning');
        log(`üíæ Book saved in IndexedDB only`, 'warning');
        return;
    }
    
    const bookFileName = `ai.book.${config.targetDomain}.lrb`;
    const apiUrl = `https://api.github.com/repos/${config.targetRepo}/contents/${bookFileName}`;
    
    log(`üì§ Pushing ${bookFileName} to GitHub...`, 'info');
    
    try {
        const encodedContent = btoa(unescape(encodeURIComponent(bookJson)));
        const commitMessage = `üìö Update ${bookFileName} - ${state.processedRepos.length} repos [${new Date().toISOString()}]`;
        
        const body = { message: commitMessage, content: encodedContent };
        
        if (state.existingFileSha) {
            body.sha = state.existingFileSha;
            log(`üîÑ Updating existing file (SHA: ${state.existingFileSha.substring(0, 8)}...)`, 'info');
        } else {
            log(`üÜï Creating new file in repo`, 'info');
        }
        
        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Accept': 'application/vnd.github.v3+json',
                'Authorization': `token ${config.githubToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        
        state.quotaUsed += 0.002;
        
        if (response.ok) {
            const result = await response.json();
            state.existingFileSha = result.content.sha;
            log(`‚úÖ Pushed to GitHub: ${bookFileName} (${(bookSize / 1024).toFixed(2)} KB)`, 'success');
            log(`üîó Commit: ${result.commit.sha.substring(0, 8)} - ${result.commit.html_url}`, 'success');
        } else {
            const error = await response.json();
            throw new Error(error.message || `Status ${response.status}`);
        }
    } catch (e) {
        log(`‚ùå Push failed: ${e.message}`, 'error');
        log(`üíæ Book saved locally in IndexedDB (will retry next cycle)`, 'warning');
    }
}

// ============================================================================
// CLEANUP
// ============================================================================

async function cleanupTemporaryData() {
    log('üóëÔ∏è Cleaning up temporary data...', 'info');
    
    try {
        // Clear temporary repo files from IndexedDB
        const tx = db.transaction(['repos'], 'readwrite');
        await tx.objectStore('repos').clear();
        
        log('‚úÖ Temporary data cleaned', 'success');
        postMessage({ type: 'storage-update' });
        
    } catch (e) {
        log(\`‚ö†Ô∏è Cleanup failed: \${e.message}\`, 'warning');
    }
}

async function cleanup() {
    log('üßπ Final cleanup...', 'info');
    await saveState();
    await cleanupTemporaryData();
    log('‚úÖ Cleanup complete', 'success');
}

// ============================================================================
// INDEXEDDB OPERATIONS
// ============================================================================

function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('AIBookFactory', 1);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            
            if (!db.objectStoreNames.contains('state')) {
                db.createObjectStore('state');
            }
            
            if (!db.objectStoreNames.contains('books')) {
                db.createObjectStore('books');
            }
            
            if (!db.objectStoreNames.contains('repos')) {
                db.createObjectStore('repos');
            }
        };
    });
}

async function saveState() {
    const tx = db.transaction(['state'], 'readwrite');
    await tx.objectStore('state').put(state, 'factoryState');
}

async function loadState() {
    const tx = db.transaction(['state'], 'readonly');
    return await tx.objectStore('state').get('factoryState');
}

async function storeBook(book) {
    const tx = db.transaction(['books'], 'readwrite');
    await tx.objectStore('books').put(book, config.targetDomain);
}

async function storeTemporaryFiles(repoName, files) {
    const tx = db.transaction(['repos'], 'readwrite');
    await tx.objectStore('repos').put(files, repoName);
}

// ============================================================================
// UTILITIES
// ============================================================================

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function waitNextHour() {
    const now = Date.now();
    const elapsed = now - state.cycleStartTime;
    const remaining = 3600000 - elapsed; // 1 hour in ms
    
    if (remaining > 0) {
        const minutes = Math.ceil(remaining / 60000);
        log(\`‚è∞ Waiting \${minutes} minutes for next hour...\`, 'info');
        postMessage({ 
            type: 'log', 
            data: { message: \`Next run in \${minutes} minutes\`, level: 'info' }
        });
        await sleep(remaining);
    }
}

function updateStats() {
    postMessage({
        type: 'stats',
        data: {
            cycle: state.cycle,
            reposProcessed: state.processedRepos.length,
            quotaUsed: state.quotaUsed,
            bookSize: state.currentBook ? new Blob([JSON.stringify(state.currentBook)]).size : 0
        }
    });
}

function log(message, level = 'info') {
    postMessage({
        type: 'log',
        data: { message, level }
    });
}
`;
        }
    </script>
</body>
</html>
